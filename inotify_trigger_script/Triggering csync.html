<h2 id="summary-of-the-problem">Summary of the problem</h2>
<p>Updating of cluster peers is taking too long on a directory with over 170,000 files. The delay of around 6 seconds causes the other peers to update their own caches which then cause further syncs. It is important to sync files immediately (maximum 2 second time-frame).</p>
<p>The existing csync2 -x option causes all files in included directories to be checked individually. This involves multiple database reads and file stat calls for every file. Running a csync check command constantly on a directory with over 170,000 files must be quite an intensive task for each server.</p>
<h2 id="solution">Solution</h2>
<p>I decided that the optimal solution is to use the kernel inotify system (via inotify-tools) and an external script to inform csync of altered files.</p>
<p>I have chosen an external script over adding inotify support to csync for the following reasons:</p>
<ul>
<li>The server/daemon modes in csync are purely for receiving and responding to network commands - the server modes are not for updating file status</li>
<li>Updating csync externally is how it was designed to be used</li>
<li>The inotify tools are mature and battle-tested unlike any additions to the somewhat fragile csync codebase</li>
<li>A simple bash script gives you more flexibility and freedom to makes changes</li>
</ul>
<p>The main point of this script is that it will only run when files actually change - it will then react and sync immediately. There is no constant checking of all files to see if they’ve changed.</p>
<p>The new script is called <code>inotify-trigger.sh</code>.</p>
<h2 id="workings">Workings</h2>
<ol type="1">
<li>Included and excluded directories are pulled from the csync2.cfg file</li>
<li>inotify monitors these locations in the background and adds changed files to a FIFO queue (a file of your choosing)</li>
<li>The queue is then read periodically (default every 0.5 seconds) and passed onto csync</li>
<li>csync runs in two stages:
<ol type="1">
<li>marks all the changed files as dirty</li>
<li>sends all dirty files to peers - this update will include <em>all</em> dirty files so any left over from previous times (or added in other ways) will be transferred</li>
</ol></li>
</ol>
<ul>
<li>Adding and reading the file queue uses a lock to ensure nothing is lost between the two parallel processes - it slows down filling of the queue a little but not the processing part.</li>
<li>Locations are monitored using <code>inotifywait</code> which then pipes changed filenames for adding to the queue. Because it uses pipes, the kernel will block subsequent notifications until the current one has been handled - in other words, all file notifications will be safely handled in turn.</li>
</ul>
<p>The script has no options of its own. Anything passed to it will be passed onto the <code>csync2</code> calls.</p>
<p>Example</p>
<p><code>./inotify-trigger.sh -N 2.csync2.test</code></p>
<p>At the top of the script are variables for the update interval, the queue outfile, the file events to monitor and the csync system directory (defaults to /etc) and config file name.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Directories are monitored recursively</li>
<li>I have selected these file events: create,modify,move,delete - we want to keep the list as short as possible</li>
<li>The <code>close_write</code> inotify file event also catches actions <code>modify</code>, <code>attrib</code> and <code>create</code> which often results in double notifications - that’s why I’m not using it</li>
<li>It is best to change the csync tempdir to an external directory so that temp files in the watched directories do not trigger a sync (but temp files will not be synced because they do not exist in the csync db)</li>
<li><strong>The directory specified for the tempdir config must be on the same filesystem as the watched directories</strong> - see csync manual for details</li>
</ul>
<h2 id="installation">Installation</h2>
<p>Dependent on <code>inotify-tools</code> which should be available in most package managers.</p>
<p>The new <code>inotify-trigger.sh</code> script <strong>replaces</strong> your other automatic checking scripts (-x option) - disable that on all servers.</p>
<p>The new script should be <strong>run once at startup on each server</strong>. It stays open with inotifywait in monitor mode. You could use systemd to launch this at startup.</p>
<p>The csync servers are still required as before for receiving and reacting to network commands sent by csync via the <code>inotify-trigger.sh</code> script. You can run that with inetd or systemd.</p>
